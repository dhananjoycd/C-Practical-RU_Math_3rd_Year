# RU Mathematics 3rd Year C Programming Lab Practicals - [DHANANJOY CHANDRA DAS]

### **ðŸ“š Course Description**

This repository contains the source code and solutions for the **C Programming Lab Practicals** conducted as part of the **Mathematics Department, Rajshahi University (RU) 3rd Year Course 3019**.

The practical sessions focus on implementing various mathematical and computational concepts using the **C programming language**. Students can use this resource for studying, understanding the implementation logic, and verifying their own solutions.

### **Output Convention**

Each C source file (`.c`) in this repository follows a specific convention to show the expected output of the program.

The **output** generated by the code when compiled and executed is placed inside a C-style multi-line comment block at the end of the file, structured like this:

```c
/*
-----------------------
EXPECTED OUTPUT
-----------------------
*/
```

1(a) - The problem we are solving is known as the **"Bisection Method for Finding Roots"**.

```c
#include<stdio.h>
#include<math.h>

 float f(float x)
 {
    return (pow(x,3)-x-1);
 }

 int main()
 {
    float a,b,tol,m,h;
    int i=0;
    printf("Enter the interval [a,b]: ");
    scanf("%f%f",&a,&b);
    if(f(a)*f(b)==0){
        if(f(a)==0)
            printf("%f is a root of f(x)\n",a);
        else
            printf("%f is a root of f(x)\n",b);
    }
    else if(f(a)*f(b)<0){
     printf("Enter the tolerance \n");
     scanf("%f",&tol);
     while(1){
             i++;
  h=fabs(a-b);
  m=(a+b)/2;
  if(f(a)*f(m)<0) b=m;
  else a=m;
  if(h<tol) break;
     }
     printf("%f is an approximate root of f(x)\n",m);
     printf("Functional value of f(x)at %f is %f\n",m,f(m));
     printf("Number of iteration is %d\n",i);
    }
    else printf("f may not have a root in the interval");
    return 0;
 }

 /* This program can find a root of given equation by bisection method.
    // Given equation is : x3-x-1=0

----------out put---------
Enter the interval [a,b]: 1 2

Enter the tolerance
0.0001
1.324738 is an approximate root of f(x)
Functional value of f(x)at 1.324738 is 0.000084
Number of iteration is 15

Process returned 0 (0x0)   execution time : 11.111 s
Press any key to continue.
-----------------------------------
*/


/*Solve hints:

-Sub function build
-Main Function build:
        .variable declaration and take interval value
        .check the root by using "if"
         => f(a)*f(b)=0 then we can find root 'a' or 'b'
         => f(a)*f(b)<0 then need tolerance and use "while loop"
         Here, m =(a+b)/2 => f(a)*f(m)<0 b=m else a=m
         Now check, h=fabs(a-b)<tolerance to stop the loop
-Print OutPut

*/

```

1(b) This program can find a root of given equation by
**false position method**. Given equation is : x3-2x-5=0

```c
#include <stdio.h>
#include <math.h>

float f(float x){
    return pow(x, 3) - 2*x - 5;
}

int main() {
    float a, b, m, tol, h;
    int i = 0, max_iteration = 1000;

    printf("Enter interval [a, b]: ");
    scanf("%f %f", &a, &b);

    // Case: Root present at boundary
    if(f(a) * f(b) == 0){
        if(f(a) == 0 && f(b) == 0)
            printf("Both are roots: a = %.6f, b = %.6f\n", a, b);
        else if(f(a) == 0)
            printf("Root is: %.6f\n", a);
        else
            printf("Root is: %.6f\n", b);

        return 0;
    }

    // Case: No root in interval
    if(f(a) * f(b) > 0){
        printf("No real root in [%f, %f]\n", a, b);
        return 0;
    }

    // Accept tolerance
    printf("Enter tolerance: ");
    scanf("%f", &tol);

    // False Position iterations
    do {
        m = (a * f(b) - b * f(a)) / (f(b) - f(a)); // false position formula
        h = fabs(m - a);  // interval contraction

        if(f(a) * f(m) > 0)
            a = m;
        else
            b = m;

        i++;
        if(i > max_iteration){
            printf("Stopped! Maximum iteration reached.\n");
            break;
        }

    } while(h > tol);

    printf("Approximate Root = %.6f\n", m);
    printf("f(%.6f) = %.6f\n",m,f(m));
    printf("Iterations = %d\n", i);

    return 0;
}

/*
Enter interval [a, b]: 2 3
Enter tolerance: 0.001
Approximate Root = 2.094306
f(2.094306) = -0.002745
Iterations = 6

Process returned 0 (0x0)   execution time : 7.000 s
Press any key to continue.

*/

/*Solve hints:

-Sub function build
-Main Function build:
        .variable declaration and take interval value
        .check the root by using "if"
         => f(a)*f(b)=0 then we can find root 'a' or 'b'
         => f(a)*f(b)>0 no real root
         => then need tolerance and use "do while loop"
         Here, m =((a * f(b) - b * f(a)) / (f(b) - f(a)) and  h=fabs(m-a)
        Thus, f(a)*f(m)>0 a=m else b=m then i++ and check i>max iteration
         Now check, h>tolerance to stop the loop
-Print OutPut

*/
```

1(c) This program can find a root of given equation by
**Newton Raphsan method**. Given equation is : x3-3x-5=0

```c
#include <stdio.h>
#include <math.h>

// Function definition for f(x)
float f(float x) {
    return (sin(x)-x/2);
}

// Function definition for f'(x)
float df(float x) {
    return cos(x)-0.5;
}

int main() {
    float x, x1, h, t;

    printf("Enter the initial point: ");
    scanf("%f", &x);

    if (df(x) == 0) {
        printf("The given point is not suitable.\n");
        return 0;
    }

    printf("Enter the tolerance: ");
    scanf("%f", &t);

    do {
        x1 = x - (f(x) / df(x));
        h = fabs(x - x1);
        x = x1;
    } while (h > t);

    printf("The Real Root is %f and f(%f) = %f\n", x, x, f(x));

    return 0;
}

/*
Enter the initial point: 1.5708
Enter the tolerance: .0001
The Real Root is 1.895494 and f(1.895494) = 0.000000

Process returned 0 (0x0)   execution time : 28.031 s
Press any key to continue.

*/


```

1(d) This program can find a root of given equation by
**Iteration method**. Given equation is : x3+x2-1=0

```c
#include <stdio.h>
#include <math.h>

// Original equation: x^3 + x^2 - 1 = 0
float f(float x)
{
    return (pow(x, 3) + pow(x, 2) - 1);
}

// Iteration function g(x) = 1 / sqrt(x + 1)
float g(float x)
{
    return (1.0 / sqrt(x + 1));
}

// g'(x)
float gprime(float x)
{
    return (-0.5 * pow(x + 1, -1.5));
}

int main()
{
    float x, x1, tol, h;
    int i = 0;

    printf("Enter initial guess x = ");
    scanf("%f", &x);

    // Check convergence condition |g'(x)| < 1
    if (fabs(gprime(x)) >= 1)
    {
        printf("The given initial guess is NOT suitable because |g'(x)| >= 1\n");
        return 0;
    }

    printf("Enter tolerance: ");
    scanf("%f", &tol);

    printf("\n Iteration results:\n");
    printf("Iteration \t   x\n");

    do
    {
        i++;
        x1 = g(x);
        h = fabs(x1 - x);
        printf("%d\t%f\n", i, x1);
        x = x1;
    } while (h > tol);

    printf("\n Approximate root = %f \n", x1);
    printf("The functional value f(%f) = %f\n", x1, f(x1));
    printf("Total iterations = %d\n",i);

    return 0;
}

/*
Enter initial guess x =
0.5
Enter tolerance: 0.0001

 Iteration results:
Iteration          x
1       0.816497
2       0.741964
3       0.757671
4       0.754278
5       0.755007
6       0.754850
7       0.754884

 Approximate root = 0.754884
The functional value f(0.754884) = 0.000019
Total iterations = 7

Process returned 0 (0x0)   execution time : 33.668 s
Press any key to continue.
*/

```

**2(a) Newton Forward**

```c
#include <stdio.h>
#include <math.h>

// Function to compute p(p-1)(p-2).../n!
float F(float p, int n){

    float num = 1, fact = 1;
    for (int i = 0; i < n; i++){
    num *= (p - i);
    fact *= i+1;
}
    return num / fact;
}

int main()
{
    int n;
    float x, h, xp, p;
    float y[20], d[20][20], sum;

    printf("Enter number of data points: ");
    scanf("%d", &n);

    printf("Enter initial x value: ");
    scanf("%f", &x);

    printf("Enter common difference h: ");
    scanf("%f", &h);

    printf("Enter y values:\n");
    for (int i = 0; i < n; i++)
        scanf("%f", &y[i]);

    printf("Enter value of x to interpolate: ");
    scanf("%f", &xp);

    // Place y values into d[0]
    for (int i = 0; i < n; i++)
        d[i][0] = y[i];

    // Build row-wise difference table
    for (int col = 1; col < n; col++)
    {
        for (int row = 0; row < n - col; row++)
        {
            d[row][col] = d[row + 1][col - 1] - d[row][col - 1];
        }
    }

    // Print header dynamically
    printf("Index     y");
    for (int i = 1; i < n; i++)
        printf("      D%dy", i);
    printf("\n");

    // Print table rows
    for (int i = 0; i < n; i++)
    {
        printf("%2d   ", i); // index printing
        for (int j = 0; j < n - i; j++)
            printf("%8.4f ", d[i][j]);
        printf("\n");
    }

    // Newton forward interpolation
    p = (xp - x) / h;
    sum = d[0][0];

    for (int i = 1; i < n; i++)
        sum += F(p, i) * d[0][i];

    printf("\n Interpolated value at x = %.4f is %.4f\n", xp, sum);
    return 0;
}

/* Enter number of data points: 6
Enter initial x value: 2.5
Enter common difference h: .5
Enter y values:
24.145
22.043
20.225
18.644
17.262
16.047
Enter value of x to interpolate: 3.75

Row-wise Difference Table:
Index     y      D1y      D2y      D3y      D4y      D5y
 0    24.1450  -2.1020   0.2840  -0.0470   0.0090  -0.0030
 1    22.0430  -1.8180   0.2370  -0.0380   0.0060
 2    20.2250  -1.5810   0.1990  -0.0320
 3    18.6440  -1.3820   0.1670
 4    17.2620  -1.2150
 5    16.0470

 Interpolated value at x = 3.7500 is 19.4074

Process returned 0 (0x)   execution time : 25.456 s
Press any key to continue.
*/

```

2(b) Newton Backword

```c
#include <stdio.h>
#include <math.h>

// Function to compute p(p+1)(p+2)... / n!
float B(float p, int n)
{
    float num = 1, fact = 1;
    for (int i = 0; i < n; i++){
        num *= (p + i);
        fact *= i+1;
    }

    return num / fact;
}

int main()
{
    int n;
    float x, h, xp, p;
    float y[20][20], xv[20], sum;

    printf("Enter number of data points: ");
    scanf("%d", &n);

    printf("Enter initial x value: ");
    scanf("%f", &x);

    printf("Enter common difference h: ");
    scanf("%f", &h);


    printf("Enter y values:\n");
    for (int i = 0; i < n; i++)
        scanf("%f", &y[i][0]);

    printf("\nEnter value of x to interpolate: ");
    scanf("%f", &xp);


    // Generate x-values
    for (int i = 0; i < n; i++)
        xv[i] = x + i * h;

    // Build backward difference table (row-wise)
    for (int col = 1; col < n; col++)
    {
        for (int row = n - 1; row >= col; row--)
        {
            y[row][col] = y[row][col - 1] - y[row - 1][col - 1];
        }
    }

    // Print dynamic header
    printf("\nIndex     x        y");
    for (int i = 1; i < n; i++)
        printf("      D%dy", i);
    printf("\n");

    // Print table
    for (int i = 0; i < n; i++)
    {
        printf("%2d   %8.4f ", i, xv[i]);
        for (int j = 0; j <= i; j++)
            printf("%8.4f ", y[i][j]);
        printf("\n");
    }

    // Interpolation
    p = (xp - xv[n - 1]) / h;  // backward p
    sum = y[n - 1][0];         // last y

    for (int i = 1; i < n; i++)
        sum += B(p, i) * y[n - 1][i];

    printf("\nInterpolated value at x = %.4f is %.4f\n", xp, sum);

    return 0;
}



/*
Enter number of data points: 8
Enter initial x value: 1
Enter common difference h: 1
Enter y values:
1 8 27 64 125 216 343 512

Index     x        y      D1y      D2y      D3y      D4y      D5y      D6y      D7y
 0     1.0000   1.0000
 1     2.0000   8.0000   7.0000
 2     3.0000  27.0000  19.0000  12.0000
 3     4.0000  64.0000  37.0000  18.0000   6.0000
 4     5.0000 125.0000  61.0000  24.0000   6.0000   0.0000
 5     6.0000 216.0000  91.0000  30.0000   6.0000   0.0000   0.0000
 6     7.0000 343.0000 127.0000  36.0000   6.0000   0.0000   0.0000   0.0000
 7     8.0000 512.0000 169.0000  42.0000   6.0000   0.0000   0.0000   0.0000   0.0000

Enter value of x to interpolate: 7.5

Interpolated value at x = 7.5000 is 421.8750

Process returned 0 (0x0)   execution time : 55.940 s
Press any key to continue.

*/

```

2(c) Lagrangeâ€™s interpolation formula

```c
#include <stdio.h>
#include <math.h>

int main() {
    int n, i, j;
    float x[100], y[100], xp;
    float yp = 0, p;

    printf("Enter number of data points: ");
    scanf("%d", &n);

    printf("Enter x values:\n");
    for(i = 0; i < n; i++)
        scanf("%f", &x[i]);

    printf("Enter y values:\n");
    for(i = 0; i < n; i++)
        scanf("%f", &y[i]);

    printf("Enter the value of x for interpolation: ");
    scanf("%f", &xp);

    // Lagrange Interpolation Formula
    for(i = 0; i < n; i++){
        p = 1;
        for(j = 0; j < n; j++){
            if(j != i)
                p = p * ( (xp - x[j]) / (x[i] - x[j]) );
        }
        yp = yp + p * y[i];
    }

    printf("\n Interpolated value at x = %.4f is y = %.4f\n", xp, yp);

    return 0;
}

/*
Enter number of data points: 4
Enter x values:
5
6
9
11
Enter y values:
12
13
14
16
Enter the value of x for interpolation: 10

Interpolated value at x = 10.0000 is y = 14.6667

Process returned 0 (0x0)   execution time : 48.994 s
Press any key to continue.

*/

```

3(a) First Derivative

```c
#include <stdio.h>
#include <math.h>


int main() {
    int n, i, j;
    float x[50], y[50], d[50][50];
    float a, h, u, sum = 0, derivative;

    printf("Enter number of data points: ");
    scanf("%d", &n);

    printf("Enter the initial value x: ");
    scanf("%f", &x[0]);

    printf("Enter distance between x values h: ");
    scanf("%f", &h);

    printf("Enter y values:\n");
    for(i=0; i<n; i++)
        scanf("%f", &y[i]);

    // Generate x array
    for(i=1; i<n; i++)
        x[i] = x[i-1] + h;

    // Difference table
    for(i=0; i<n; i++)
        d[0][i] = y[i];

    for(i=1; i<n; i++)
        for(j=0; j<n-i; j++)
            d[i][j] = d[i-1][j+1] - d[i-1][j];

    printf("\nDifference Table:\n");
    for(i=1; i<n; i++) {
        for(j=0; j<n-i; j++)
            printf("%f\t", d[i][j]);
        printf("\n");
    }

    printf("\nEnter x value where derivative is required: ");
    scanf("%f", &a);

    u = (a - x[0]) / h;

    // Apply Newton forward derivative formula
    sum  = d[1][0];
    sum += (2*u - 1) * d[2][0] / 2;
    sum += (3*u*u - 6*u + 2) * d[3][0] / 6;
    sum += (4*u*u*u - 18*u*u + 22*u - 6) * d[4][0] / 24;

    derivative = sum / h;

    printf("\nFirst derivative at x = %.4f is %.4f\n", a, derivative);

    return 0;
}

/*
Enter number of data points: 5
Enter the initial value x: 0
Enter distance between x values h: 1
Enter y values:
0
2
18
84
260

Difference Table:
2.000000        16.000000       66.000000       176.000000
14.000000       50.000000       110.000000
36.000000       60.000000
24.000000

Enter x value where derivative is required: 3

First derivative at x = 3.0000 is 109.0000

Process returned 0 (0x0)   execution time : 21.072 s
Press any key to continue.
*/

```

3(b) 2nd Derivative

```c
#include <stdio.h>
#include <math.h>

int main() {
    int n, i, j;
    float x[50], y[50], d[50][50];
    float a, h, u, sum, second_derivative;

    printf("Enter number of data points: ");
    scanf("%d", &n);

    printf("Enter initial value x: ");
    scanf("%f", &x[0]);

    printf("Enter distance h: ");
    scanf("%f", &h);

    printf("Enter y values:\n");
    for (i = 0; i < n; i++)
        scanf("%f", &y[i]);

    // Generate x array
    for (i = 1; i < n; i++)
        x[i] = x[i - 1] + h;

    // Create forward difference table
    for (i = 0; i < n; i++)
        d[0][i] = y[i];

    for (i = 1; i < n; i++)
        for (j = 0; j < n - i; j++)
            d[i][j] = d[i - 1][j + 1] - d[i - 1][j];

    printf("\nDifference Table:\n");
    for (i = 1; i < n; i++) {
        for (j = 0; j < n - i; j++)
            printf("%f\t", d[i][j]);
        printf("\n");
    }

    printf("\nEnter x value where 2nd derivative is required: ");
    scanf("%f", &a);

    u = (a - x[0]) / h;

    // Newton forward 2nd derivative formula
    sum  = d[2][0];                                         // Î”Â²y0
    sum += (6*u - 6) * d[3][0] / 6;                         // (6uâˆ’6)/3!
    sum += (12*u*u - 36*u + 22) * d[4][0] / 24;             // (12uÂ²âˆ’36u+22)/4!

    second_derivative = sum / (h * h);

    printf("\nSecond derivative at x = %.4f is %.4f\n", a, second_derivative);

    return 0;
}

/*
Enter number of data points: 5
Enter initial value x: 0
Enter distance h: 1
Enter y values:
0
2
18
84
260

Difference Table:
2.000000        16.000000       66.000000       176.000000
14.000000       50.000000       110.000000
36.000000       60.000000
24.000000

Enter x value where 2nd derivative is required: 3

Second derivative at x = 3.0000 is 108.0000

Process returned 0 (0x0)   execution time : 35.820 s
Press any key to continue.

*/

```

First Derivative & 2nd Derivative

```c
#include <stdio.h>
#include <math.h>

int main() {
    int n, i, j;
    float x[50], y[50], d[50][50];
    float a, h, u;
    float first_sum, second_sum;
    float first_derivative, second_derivative;

    printf("Enter number of data points: ");
    scanf("%d", &n);

    printf("Enter initial value x: ");
    scanf("%f", &x[0]);

    printf("Enter distance h: ");
    scanf("%f", &h);

    printf("Enter y values:\n");
    for (i = 0; i < n; i++)
        scanf("%f", &y[i]);

    // Generate x array
    for (i = 1; i < n; i++)
        x[i] = x[i - 1] + h;

    // Construct forward difference table
    for (i = 0; i < n; i++)
        d[0][i] = y[i];

    for (i = 1; i < n; i++)
        for (j = 0; j < n - i; j++)
            d[i][j] = d[i - 1][j + 1] - d[i - 1][j];

    printf("\nDifference Table:\n");
    for (i = 1; i < n; i++) {
        for (j = 0; j < n - i; j++)
            printf("%f\t", d[i][j]);
        printf("\n");
    }

    printf("\nEnter x value where derivative is required: ");
    scanf("%f", &a);

    u = (a - x[0]) / h;

    /********** First Derivative **********/
    first_sum  = d[1][0];
    first_sum += (2*u - 1) * d[2][0] / 2;
    first_sum += (3*u*u - 6*u + 2) * d[3][0] / 6;
    first_sum += (4*u*u*u - 18*u*u + 22*u - 6) * d[4][0] / 24;

    first_derivative = first_sum / h;

    /********** Second Derivative **********/
    second_sum  = d[2][0];
    second_sum += (6*u - 6) * d[3][0] / 6;
    second_sum += (12*u*u - 36*u + 22) * d[4][0] / 24;

    second_derivative = second_sum / (h * h);

    printf("\nFirst derivative f'(%f) = %.6f\n", a, first_derivative);
    printf("Second derivative f''(%f) = %.6f\n", a, second_derivative);

    return 0;
}

/*
Enter number of data points: 5
Enter initial value x: 0
Enter distance h: 1
Enter y values:
0
2
18
84
260

Difference Table:
2.000000        16.000000       66.000000       176.000000
14.000000       50.000000       110.000000
36.000000       60.000000
24.000000

Enter x value where derivative is required: 3

First derivative f'(3.000000) = 109.000000
Second derivative f''(3.000000) = 108.000000

Process returned 0 (0x0)   execution time : 50.126 s
Press any key to continue.
*/

```

4(a) Trapiozoidal Rule

```c
#include <stdio.h>
#include <math.h>

float f(float x) {
    return 1.0 / (1.0 + x); //given function
}

int main() {
    int i, n;
    float a, b, h, sum = 0, result;

    printf("Enter number of sub-intervals n: ");
    scanf("%d", &n);

    printf("Enter lower limit a: ");
    scanf("%f", &a);

    printf("Enter upper limit b: ");
    scanf("%f", &b);

    h = (b - a) / n;

    for(i = 1; i < n; i++) {
        sum += f(a + i * h);
    }

    result = (h / 2) * (f(a) + 2 * sum + f(b));

    printf("\nIntegral result using Trapezoidal Rule = %f\n", result);

    return 0;
}

/*
Enter number of sub-intervals n: 100
Enter lower limit a: 0
Enter upper limit b: 1

Integral result using Trapezoidal Rule = 0.693153

Process returned 0 (0x0)   execution time : 31.297 s
Press any key to continue.
*/
```

4(b) Simpson's 1/3

```c
#include <stdio.h>
#include <math.h>

float f(float x) {

    return sqrt(1-pow(x,2)); //function
}

int main() {
    int i, n;
    float a, b, h, sum_odd = 0, sum_even = 0, result;

    printf("Enter number of sub-intervals (n must be even): ");
    scanf("%d", &n);

    if(n % 2 != 0) {
        printf("Error: n must be even for Simpson 1/3 Rule.\n");
        return 0;
    }

    printf("Enter lower limit a: ");
    scanf("%f", &a);

    printf("Enter upper limit b: ");
    scanf("%f", &b);

    h = (b - a) / n;

    for(i = 1; i < n; i++) {
        float val = f(a + i * h);
        if(i % 2 == 0)
            sum_even += val;
        else
            sum_odd += val;
    }

    result = (h / 3) * (f(a) + f(b) + 4 * sum_odd + 2 * sum_even);

    printf("\n Simpson 1/3 Rule Result = %f\n", result);

    return 0;
}

/*
Enter number of sub-intervals (n must be even): 10
Enter lower limit a: 0
Enter upper limit b: 1

 Simpson 1/3 Rule Result = 0.781752

Process returned 0 (0x0)   execution time : 13.432 s
Press any key to continue.
*/

```

4(c) Simpson's 3/8 rule

```c
#include <stdio.h>
#include <math.h>

float f(float x) {
    return 1.0 / (1.0 + x);
}

int main() {
    int i, n;
    float a, b, h, sum3 = 0, sum2 = 0, result;

    printf("Enter number of sub-intervals  : ");
    scanf("%d", &n);

    if(n % 3 != 0) {
        printf("Error: n must be divisible by 3 for Simpson 3/8 Rule.\n");
        return 0;
    }

    printf("Enter lower limit a: ");
    scanf("%f", &a);

    printf("Enter upper limit b: ");
    scanf("%f", &b);

    h = (b - a) / n;

    for(i = 1; i < n; i++) {
        float val = f(a + i * h);

        if(i % 3 == 0)
            sum2 += val;      // coefficients = 2
        else
            sum3 += val;      // coefficients = 3
    }

    result = (3 * h / 8) * (f(a) + f(b) + 3 * sum3 + 2 * sum2);

    printf("\n Simpson 3/8 Rule Result = %f\n", result);

    return 0;
}

/*
Enter number of sub-intervals  : 9
Enter lower limit a: 0
Enter upper limit b: 1.2

 Simpson 3/8 Rule Result = 0.788478

Process returned 0 (0x0)   execution time : 29.171 s
Press any key to continue.

*/

```

5(a) Write a program to find the addition of the two
matrix

```c
#include <stdio.h>
#include <math.h>

int main() {
    int i, j, m1, n1, m2, n2;

    printf("Enter the size of Matrix A (m n): ");
    scanf("%d%d", &m1, &n1);

    printf("Enter the size of Matrix B (m n): ");
    scanf("%d%d", &m2, &n2);

    if (m1 != m2 || n1 != n2) {
        printf("Matrix addition NOT possible. Orders must match.\n");
        return 0;
    }
        //dynamic index of matrix
    float a[m1][n1], b[m2][n2], c[m1][n1];

    printf("Enter the elements of Matrix A:\n");
    for (i = 0; i < m1; i++)
        for (j = 0; j < n1; j++)
            scanf("%f", &a[i][j]);

    printf("Enter the elements of Matrix B:\n");
    for (i = 0; i < m2; i++)
        for (j = 0; j < n2; j++)
            scanf("%f", &b[i][j]);

    // Matrix Addition
    for (i = 0; i < m1; i++)
        for (j = 0; j < n1; j++)
            c[i][j] = a[i][j] + b[i][j];

    printf("\nMatrix Addition (C = A + B):\n");
    for (i = 0; i < m1; i++) {
        for (j = 0; j < n1; j++)
            printf("%.2f\t", c[i][j]);
        printf("\n");
    }

    return 0;
}

/*
Enter the size of Matrix A (m n): 3 3
Enter the size of Matrix B (m n): 3 3
Enter the elements of Matrix A:
3 4 5
7 6 4
2 4 9
Enter the elements of Matrix B:
5 3 7
4 3 6
2 6 9

Matrix Addition (C = A + B):
8.00    7.00    12.00
11.00   9.00    10.00
4.00    10.00   18.00

Process returned 0 (0x0)   execution time : 46.731 s
Press any key to continue.

*/

```

5(b). Write a program to find the multiplication of the two
matrix

```c
#include <stdio.h>
#include <math.h>

int main() {
    int i, j, k, m1, n1, m2, n2;

    printf("Enter size of Matrix A (m n): ");
    scanf("%d%d", &m1, &n1);

    printf("Enter size of Matrix B (m n): ");
    scanf("%d%d", &m2, &n2);

    // Condition for multiplication: n1 must equal m2
    if (n1 != m2) {
        printf("Matrix multiplication NOT possible.\n");
        return 0;
    }
        // Matrix declare
    float A[m1][n1], B[m2][n2], C[m1][n2];

    printf("\nEnter elements of Matrix A:\n");
    for (i = 0; i < m1; i++)
        for (j = 0; j < n1; j++)
            scanf("%f", &A[i][j]);

    printf("\nEnter elements of Matrix B:\n");
    for (i = 0; i < m2; i++)
        for (j = 0; j < n2; j++)
            scanf("%f", &B[i][j]);

    // Initialize C to zero
    for (i = 0; i < m1; i++)
        for (j = 0; j < n2; j++)
            C[i][j] = 0;

    // Matrix Multiplication: C = A Ã— B
    for (i = 0; i < m1; i++) {
        for (j = 0; j < n2; j++) {
            for (k = 0; k < n1; k++) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }

    printf("\nResultant Matrix (C = A Ã— B):\n");
    for (i = 0; i < m1; i++) {
        for (j = 0; j < n2; j++)
            printf("%.2f\t", C[i][j]);
        printf("\n");
    }

    return 0;
}

/*
Enter size of Matrix A (m n): 3 2
Enter size of Matrix B (m n): 2 3

Enter elements of Matrix A:
1 1
2 2
3 3

Enter elements of Matrix B:
1 1 1
2 2 2

Resultant Matrix (C = A * B):
3.00    3.00    3.00
6.00    6.00    6.00
9.00    9.00    9.00

Process returned 0 (0x0)   execution time : 30.626 s
Press any key to continue.

*/

```

5(c) Write a program to the scalar multiplication of matrix

```c
#include <stdio.h>
#include <math.h>

int main() {
    int i, j, m, n;
    float k;

    printf("Enter the order of the matrix (m n): ");
    scanf("%d%d", &m, &n);

    float A[m][n], C[m][n];

    printf("Enter the scalar value k: ");
    scanf("%f", &k);

    printf("Enter elements of Matrix A:\n");
    for (i = 0; i < m; i++)
        for (j = 0; j < n; j++)
            scanf("%f", &A[i][j]);

    // Scalar multiplication: C = k Ã— A
    for (i = 0; i < m; i++)
        for (j = 0; j < n; j++)
            C[i][j] = k * A[i][j];

    printf("\n Resultant Matrix (C = k Ã— A):\n");
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++)
            printf("%.2f\t", C[i][j]);
        printf("\n");
    }

    return 0;
}

/*
Enter the order of the matrix (m n): 2 2
Enter the scalar value k: 3
Enter elements of Matrix A:
1 2
4 5

Resultant Matrix (C = k * A):
3.00    6.00
12.00   15.00

Process returned 0 (0x0)   execution time : 15.884 s
Press any key to continue.
*/

```

5(d) Write a program to find the Transpose of a matrix

```c
#include <stdio.h>
#include <math.h>

int main() {
    int i, j, m, n;

    printf("Enter the order of the matrix (m n): ");
    scanf("%d%d", &m, &n);

    float A[m][n], T[n][m];

    printf("Enter the elements of Matrix A:\n");
    for (i = 0; i < m; i++)
        for (j = 0; j < n; j++)
            scanf("%f", &A[i][j]);

    // Transpose: T[j][i] = A[i][j]
    for (i = 0; i < m; i++)
        for (j = 0; j < n; j++)
            T[j][i] = A[i][j];

    printf("\nTranspose Matrix (A^T):\n");
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++)
            printf("%.2f\t", T[i][j]);
        printf("\n");
    }

    return 0;
}
/*
Enter the order of the matrix (m n): 3 3
Enter the elements of Matrix A:
1 2 3
4 5 6
7 8 9

Transpose Matrix (A^T):
1.00    4.00    7.00
2.00    5.00    8.00
3.00    6.00    9.00

Process returned 0 (0x0)   execution time : 821.308 s
Press any key to continue.
*/

```

5(e) Write a program to find the row interchange matrix of a
matrix

```c
#include <stdio.h>
#include <math.h>

int main() {
    float a[10][10], temp;
    int m, n, r1, r2, i, j;

    printf("Enter the order of matrix A (m n): ");
    scanf("%d%d", &m, &n);

    printf("Enter the elements of matrix A:\n");
    for (i = 0; i < m; i++)
        for (j = 0; j < n; j++)
            scanf("%f", &a[i][j]);

    printf("Enter two rows to interchange (1-based): ");
    scanf("%d%d", &r1, &r2);

    r1--;  //convert to 0-based
    r2--;

    for (j = 0; j < n; j++) {   // swap full rows
        temp = a[r1][j];
        a[r1][j] = a[r2][j];
        a[r2][j] = temp;
    }

    printf("\nMatrix after row interchange:\n");
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++)
            printf("%.1f\t", a[i][j]);
        printf("\n");
    }

    return 0;
}
/*
Enter the order of matrix A (m n): 3 3
Enter the elements of matrix A:
1 2 3
4 5 6
7 8 9
Enter two rows to interchange (1-based): 2 3

Matrix after row interchange:
1.0     2.0     3.0
7.0     8.0     9.0
4.0     5.0     6.0

Process returned 0 (0x0)   execution time : 28.701 s
Press any key to continue.
*/

```

5(f) Write a program to find the row scaling and addition

```c
#include <stdio.h>
#include <math.h>

int main()
{
    float a[5][5], k;
    int m, n, m1, n1, i, j;

    printf("Enter order of matrix A:\n");
    scanf("%d%d", &m, &n);

    printf("Enter elements A:\n");
    for (i = 1; i <= m; i++)
        for (j = 1; j <= n; j++)
            scanf("%f", &a[i][j]);

    printf("Enter row to scale (m1) and scaling value k:\n");
    scanf("%d%f", &m1, &k);

    printf("Enter row to add (n1):\n");
    scanf("%d", &n1);

    for (j = 1; j <= n; j++)
        a[m1][j] = k * a[m1][j] + a[n1][j];

    printf("Matrix after scaling:\n");
    for (i = 1; i <= m; i++)
    {
        for (j = 1; j <= n; j++)
            printf("%.1f\t", a[i][j]);
        printf("\n");
    }
}

/*
Enter order of matrix A:
3 3
Enter elements A:
1 2 3
4 5 6
7 8 9
Enter row to scale (m1) and scaling value k:
3 2
Enter row to add (n1):
1
Matrix after scaling:
1.0     2.0     3.0
4.0     5.0     6.0
15.0    18.0    21.0

Process returned 0 (0x0)   execution time : 26.401 s
Press any key to continue.

*/

```

5(g) Write a program to find the square matrix sum of
symmetric and skewsymmetric

```c
#include <stdio.h>
#include <math.h>

int main() {
    float a[10][10], s[10][10], sk[10][10];
    int i, j, n;

    printf("Enter the order of Square matrix A: ");
    scanf("%d", &n);

    printf("Enter the elements of matrix A:\n");
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            scanf("%f", &a[i][j]);

    // Symmetric matrix S = (A + A')/2
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            s[i][j] = (a[i][j] + a[j][i]) * 0.5;

    printf("\nSymmetric Matrix S:\n");
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++)
            printf("%.2f\t", s[i][j]);
        printf("\n");
    }

    // Skew-Symmetric matrix K = (A - A')/2
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            sk[i][j] = (a[i][j] - a[j][i]) * 0.5;

    printf("\nSkew-Symmetric Matrix K:\n");
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++)
            printf("%.2f\t", sk[i][j]);
        printf("\n");
    }

    // Optional: Verify S + K = A
    printf("\n The sum of S and K =:\n");
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++)
            printf("%.2f\t", s[i][j] + sk[i][j]);
        printf("\n");
    }

    return 0;
}
/*
Enter the order of Square matrix A: 3
Enter the elements of matrix A:
4 2 -1
3 1 5
0 -2 6

Symmetric Matrix S:
4.00    2.50    -0.50
2.50    1.00    1.50
-0.50   1.50    6.00

Skew-Symmetric Matrix K:
0.00    -0.50   -0.50
0.50    0.00    3.50
0.50    -3.50   0.00

The sum of S and K =:
4.00    2.00    -1.00
3.00    1.00    5.00
0.00    -2.00   6.00

Process returned 0 (0x0)   execution time : 37.324 s
Press any key to continue.

*/

```

5(h) Write a program to find the matrix polynomial
F(A)= F(A) = A^3 - 5A^2 + 7A - 3I

```c
#include <stdio.h>
#include <math.h>

int main() {
    int i, j, k, n;
    float A[5][5], A2[5][5], A3[5][5], I[5][5], F[5][5];

    printf("Enter order of Square matrix A: ");
    scanf("%d", &n);

    printf("Enter elements of matrix A:\n");
    for(i = 1; i <= n; i++)
        for(j = 1; j <= n; j++)
            scanf("%f", &A[i][j]);

    // Create identity matrix automatically
    for(i = 1; i <= n; i++)
        for(j = 1; j <= n; j++)
            I[i][j] = (i == j) ? 1 : 0;

    //-----Build Matrix polynomial----

    // Compute A^2
    for(i = 1; i <= n; i++)
        for(j = 1; j <= n; j++) {
            A2[i][j] = 0;
            for(k = 1; k <= n; k++)
                A2[i][j] += A[i][k] * A[k][j];
        }

    // Compute A^3
    for(i = 1; i <= n; i++)
        for(j = 1; j <= n; j++) {
            A3[i][j] = 0;
            for(k = 1; k <= n; k++)
                A3[i][j] += A2[i][k] * A[k][j];
        }

    // -------- Write polynomial Equation --------

    // F(A) = A^3 - 5A^2 + 7A - 3I
    for(i = 1; i <= n; i++)
        for(j = 1; j <= n; j++)
            F[i][j] = A3[i][j] - 5*A2[i][j] + 7*A[i][j] - 3*I[i][j];

    printf("\n Result of matrix polynomial F(A):\n");
    for(i = 1; i <= n; i++) {
        for(j = 1; j <= n; j++)
            printf("%.2f\t", F[i][j]);
        printf("\n");
    }

    return 0;
}

/*
Enter order of Square matrix A: 2
Enter elements of matrix A:
1 2
3 4

 Result of matrix polynomial F(A):
6.00    18.00
27.00   33.00

Process returned 0 (0x0)   execution time : 14.390 s
Press any key to continue.

*/

```

6A. Jacobi Method

```c
#include <stdio.h>
#include <math.h>

int main() {
    int n, i, j, iter;
    float a[10][10], b[10], x[10], x_old[10], sum;

    printf("Enter the number of variables (order of system): ");
    scanf("%d", &n);

    printf("Enter the coefficient matrix A (%dx%d):\n", n, n);
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            scanf("%f", &a[i][j]);

    printf("Enter the constants vector b:\n");
    for (i = 0; i < n; i++)
        scanf("%f", &b[i]);

    printf("Enter the number of iterations: ");
    scanf("%d", &iter);

    // Initial guess x = 0
    for (i = 0; i < n; i++)
        x[i] = 0;

    printf("\nIteration table:\n");
    for (int k = 1; k <= iter; k++) {
        // Copy previous iteration
        for (i = 0; i < n; i++)
            x_old[i] = x[i];

        // Jacobi formula
        for (i = 0; i < n; i++) {
            sum = 0;
            for (j = 0; j < n; j++) {
                if (i != j)
                    sum += a[i][j] * x_old[j];
            }
            x[i] = (b[i] - sum) / a[i][i];
        }

        // Print current iteration
        printf("Iteration %d: ", k);
        for (i = 0; i < n; i++)
            printf("%8.4f ", x[i]);
        printf("\n");
    }

    // Final approximate solution
    printf("\nApproximate solution:\n");
    for (i = 0; i < n; i++)
        printf("x_%d = %8.4f\n", i + 1, x[i]);

    return 0;
}

/*
Enter the number of variables (order of system): 3
Enter the coefficient matrix A (3x3):
27 6 -1
6 15 2
1 1 54
Enter the constants vector b:
85 72 110
Enter the number of iterations: 7

Iteration table:
Iteration 1:   3.1481   4.8000   2.0370
Iteration 2:   2.1569   3.2691   1.8898
Iteration 3:   2.4917   3.6852   1.9366
Iteration 4:   2.4009   3.5451   1.9226
Iteration 5:   2.4316   3.5833   1.9269
Iteration 6:   2.4232   3.5705   1.9257
Iteration 7:   2.4260   3.5740   1.9260

Approximate solution:
x_1 =   2.4260
x_2 =   3.5740
x_3 =   1.9260

Process returned 0 (0x0)   execution time : 58.071 s
Press any key to continue.
*/

```

6B. Gauss-Seidel Method

```c
#include <stdio.h>
#include <math.h>

int main() {
    int n, i, j, iter;
    // Arrays for up to 10 variables
    float a[10][10], b[10], x[10], x_old[10], sum;

    // --- Input Section ---
    printf("Enter the number of variables (order of system): ");
    scanf("%d", &n);

    printf("Enter the coefficient matrix A (%dx%d):\n", n, n);
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            scanf("%f", &a[i][j]);

    printf("Enter the constants vector b:\n");
    for (i = 0; i < n; i++)
        scanf("%f", &b[i]);

    printf("Enter the number of iterations: ");
    scanf("%d", &iter);

    // Initial guess: x = 0
    for (i = 0; i < n; i++)
        x[i] = 0;

    // --- Iteration Section (The Core Logic) ---
    printf("\nIteration table:\n");
    for (int k = 1; k <= iter; k++) {

        // 1. Save the previous solution set before calculating the new one
        for (i = 0; i < n; i++)
            x_old[i] = x[i];

        // 2. Apply the Gauss-Seidel formula for each variable
        for (i = 0; i < n; i++) {
            sum = 0;

            // Calculate the sum of terms (excluding the diagonal a[i][i]*x[i])
            for (j = 0; j < n; j++) {
                if (i != j) {
                    // Gauss-Seidel uses the NEWEST values available:
                    if (j < i)
                        sum += a[i][j] * x[j];      // Use updated x[j]
                    else
                        sum += a[i][j] * x_old[j];  // Use value from previous iteration
                }
            }

            // Update the current variable: x_i = (b_i - sum) / a_ii
            x[i] = (b[i] - sum) / a[i][i];
        }

        // 3. Print current iteration result
        printf("Iteration %d: ", k);
        for (i = 0; i < n; i++)
            printf("%10.4f ", x[i]);
        printf("\n");
    }

    // --- Output Section ---
    printf("\nApproximate solution:\n");
    for (i = 0; i < n; i++)
        printf("x_%d = %10.4f\n", i + 1, x[i]);

    return 0;
}
/*
Enter the number of variables (order of system): 3
Enter the coefficient matrix A (3x3):
27 6 -1
6 15 2
1 1 54
Enter the constants vector b:
85 72 110
Enter the number of iterations: 4

Iteration table:
Iteration 1:     3.1481     3.5407     1.9132
Iteration 2:     2.4322     3.5720     1.9258
Iteration 3:     2.4257     3.5729     1.9260
Iteration 4:     2.4255     3.5730     1.9260

Approximate solution:
x_1 =     2.4255
x_2 =     3.5730
x_3 =     1.9260

Process returned 0 (0x0)   execution time : 29.030 s
Press any key to continue.
*/

```

### **âš ï¸ Important Warnings and Disclaimer**

- **_Potential for Error (Bugs):_** While every effort has been made to ensure the correctness of the solutions, programming code is never 100% flawless. **There may be bugs or logical errors** in the code provided here. Please treat these files as a **study guide**, not as guaranteed, error-free solutions. **Always test and verify the code yourself.**
- **_Academic Integrity:_** This repository is intended for **educational and self-study purposes only**. **DO NOT** submit this code directly as your own work for lab assignments or examinations, as this constitutes academic misconduct.

![ `MERN Stack Web Developer & Research Enthusiast`](DHANANJOYCHANDRADAS.png)

**ðŸ‘¤ Dhananjoy Chandra Das**

`MERN Stack Web Developer & Research Enthusiast`

B.Sc. (Hons) in Mathematics, University of Rajshahi

**ðŸ“§ Email:** [dhananjoychandradas@gmail.com](mailto:dhananjoychandradas@gmail.com)

**ðŸ”— LinkedIn:** [https://www.linkedin.com/in/dhananjoycd/](https://www.linkedin.com/in/dhananjoycd/)

**ðŸ“˜ Facebook:** [https://www.facebook.com/official.dhananjoycd](https://www.facebook.com/official.dhananjoycd)

Explore code. Build ideas. Break limitsâ€¦ ðŸ’›

---
